<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Events Platform</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            line-height: 1.5;
            padding-bottom: 80px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 16px;
        }

        .header {
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
            padding: 16px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            width: 100vw;
            margin-left: -16px;
            border-bottom-left-radius: 20px;
            border-bottom-right-radius: 20px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--tg-theme-text-color, #000000);
            text-align: center;
            padding: 0 16px;
        }

        .tabs {
            display: flex;
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
            margin: 16px 0;
            border-radius: 12px;
            padding: 4px;
        }

        .tab {
            flex: 1;
            padding: 8px 12px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 14px;
        }

        .tab.active {
            background: var(--tg-theme-button-color, #0088cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            border-radius: 8px;
        }

        .filters {
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: none;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .filter-row {
            display: contents;
        }

        .date-filter {
            grid-column: 1 / -1;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .date-filter label {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
        }

        .date-filter input {
            flex: 1;
        }

        select {
            padding: 12px;
            border: 1px solid var(--tg-theme-hint-color, #e0e0e0);
            border-radius: 8px;
            background: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            font-size: 16px;
            width: 100%;
        }

        .clear-btn {
            grid-column: 1 / -1;
            padding: 10px 16px;
            border: 1px solid var(--tg-theme-hint-color, #e0e0e0);
            border-radius: 8px;
            background: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            font-size: 14px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .clear-btn:hover {
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
        }

        .feed {
            margin-top: 16px;
        }

        .event-card {
            background: var(--tg-theme-bg-color, #ffffff);
            border: 1px solid var(--tg-theme-hint-color, #e0e0e0);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
            transition: all 0.2s;
        }

        .event-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .event-content {
            background: var(--tg-theme-bg-color, #ffffff);
            padding: 16px;
        }

        .event-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--tg-theme-text-color, #000000);
            margin-bottom: 8px;
        }

        .event-description {
            font-size: 16px;
            line-height: 1.5;
            color: var(--tg-theme-text-color, #000000);
        }

        .event-footer {
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .event-author {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .event-author:hover {
            opacity: 0.8;
        }

        .author-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }

        .author-name {
            font-size: 14px;
            font-weight: 500;
            color: var(--tg-theme-text-color, #000000);
        }

        .event-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .like-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            border: none;
            border-radius: 20px;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .like-btn.liked {
            background: rgba(255, 59, 92, 0.1);
            color: #ff3b5c;
        }

        .menu-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: var(--tg-theme-hint-color, #999999);
            transition: all 0.2s;
        }

        .menu-btn:hover {
            background: var(--tg-theme-hint-color, rgba(0,0,0,0.1));
        }

        .dropdown-menu {
            position: absolute;
            right: 0;
            top: 100%;
            background: var(--tg-theme-bg-color, #ffffff);
            border: 1px solid var(--tg-theme-hint-color, #e0e0e0);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 120px;
            overflow: hidden;
            display: none;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            color: var(--tg-theme-text-color, #000000);
            transition: background 0.2s;
        }

        .dropdown-item:hover {
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
        }

        .dropdown-item.danger {
            color: #ff3b5c;
        }

        .search-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
            padding: 12px 16px;
            border-top: 1px solid var(--tg-theme-hint-color, #e0e0e0);
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .search-container {
            flex: 1;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 12px 12px 12px 40px;
            border: none;
            border-radius: 20px;
            background: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            font-size: 16px;
            outline: none;
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%) scaleX(-1);
            width: 18px;
            height: 18px;
            opacity: 0.6;
        }

        .create-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            background: var(--tg-theme-button-color, #0088cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .create-btn:hover {
            transform: scale(1.05);
        }

        .create-icon {
            width: 24px;
            height: 24px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            z-index: 10000;
            padding: 16px;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--tg-theme-bg-color, #ffffff);
            border-radius: 20px;
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 20px 0 20px;
        }

        .modal-user {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }

        .modal-user-name {
            font-size: 16px;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: var(--tg-theme-secondary-bg-color, #f8f9fa);
            color: var(--tg-theme-hint-color, #999999);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .modal-body {
            padding: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--tg-theme-text-color, #000000);
            font-size: 14px;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--tg-theme-hint-color, #e0e0e0);
            border-radius: 12px;
            background: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            outline: none;
        }

        .form-input:focus {
            border-color: var(--tg-theme-button-color, #0088cc);
        }

        .char-counter {
            text-align: right;
            font-size: 12px;
            color: var(--tg-theme-hint-color, #999999);
            margin-top: 4px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .form-date-group {
            grid-column: 1 / -1;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .form-date-group label {
            font-size: 14px;
            font-weight: 500;
            white-space: nowrap;
        }

        .form-date-group input {
            flex: 1;
        }

        .modal-footer {
            padding: 0 20px 20px 20px;
            display: flex;
            justify-content: flex-end;
        }

        .submit-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            background: var(--tg-theme-button-color, #0088cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--tg-theme-hint-color, #999999);
        }

        .error {
            background: #ffe6e6;
            color: #d32f2f;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            text-align: center;
        }

        .empty {
            text-align: center;
            padding: 40px;
            color: var(--tg-theme-hint-color, #999999);
        }

        .hidden {
            display: none !important;
        }

        .menu-container {
            position: relative;
        }

        @media (max-width: 480px) {
            .filter-grid {
                grid-template-columns: 1fr;
            }

            .date-filter {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>🎯 Events Platform 📰 📝 ⭐ 👁️</h1>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <div class="tab active" data-tab="feed">Feed</div>
            <div class="tab" data-tab="favorites">Favorites</div>
            <div class="tab" data-tab="my-events">My Events</div>
            <div class="tab" data-tab="hidden">Hidden</div>
        </div>

        <!-- Filters -->
        <div class="filters">
            <div class="filter-grid">
                <select id="cityFilter">
                    <option value="">All cities</option>
                </select>
                <select id="categoryFilter">
                    <option value="">All categories</option>
                    <option value="meetup">Meetup</option>
                    <option value="party">Party</option>
                    <option value="sport">Sport</option>
                    <option value="culture">Culture</option>
                    <option value="business">Business</option>
                    <option value="education">Education</option>
                </select>
                
                <select id="genderFilter">
                    <option value="">All genders</option>
                    <option value="male">Male</option>
                    <option value="female">Female</option>
                </select>
                <select id="ageFilter">
                    <option value="">All ages</option>
                    <option value="16-25">16-25</option>
                    <option value="25-45">25-45</option>
                    <option value="45+">45+</option>
                </select>

                <div class="date-filter">
                    <label>From:</label>
                    <input type="date" id="dateFromFilter">
                    <label>To:</label>
                    <input type="date" id="dateToFilter">
                </div>

                <button class="clear-btn" onclick="clearFilters()">Clear all filters</button>
            </div>
        </div>

        <!-- Content -->
        <div id="feedContent" class="feed"></div>
        <div id="favoritesContent" class="feed hidden"></div>
        <div id="myEventsContent" class="feed hidden"></div>
        <div id="hiddenContent" class="feed hidden"></div>
    </div>

    <!-- Search and Create Area -->
    <div class="search-area">
        <div class="search-container">
            <svg class="search-icon" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M197.001 244C171.822 271.83 126.998 313 104.256 295.496C81.5174 277.992 126.998 246 156.656 220.314" stroke="currentColor" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M165.944 196.347C135.998 107 276.999 75.9996 300.776 165.974C319.017 235 211.46 292.164 175.314 213.85" stroke="currentColor" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="">
        </div>
        <button class="create-btn" onclick="showCreateModal()">
            <svg class="create-icon" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M71.8708 189.953C76.0596 179.972 67.0124 166.184 74.2179 157.188C75.8153 155.199 122.602 153.152 125.561 155.514C136.45 164.206 111.415 193.423 144.018 201.553C171.926 208.513 155.397 160.743 162.516 157.188C171.049 152.934 188.865 158.57 198.547 157.188C226.846 153.158 203.311 181.664 211.97 193.182C217.423 200.435 261.828 185.402 250.56 219.132C244.647 236.825 226.375 230.776 216.164 235.873C211.338 238.281 215.898 272.743 215.1 272.582C205.09 270.587 157.177 275.336 158.734 276.89C168.054 286.189 186.94 229.756 144.018 235.873C133.985 237.301 125.13 246.004 123.884 255.963C123.16 261.765 125.774 278.518 125.561 278.564C113.242 281.023 100.187 277.778 86.9713 281.075C84.5867 281.671 67.5038 288.431 65.9983 286.935C63.3552 284.292 66.3776 262.486 66.8373 258.788C67.5727 252.946 65.9754 240.01 71.8708 240.01C84.7533 240.01 42.0914 251.826 29.6626 235.873C17.2337 219.92 29.6626 189.953 66.8373 198.994" stroke="currentColor" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M219.962 158.69C301.398 167.678 215.1 108.884 284.641 112.13C309.301 113.281 287.258 146.158 293.857 154.973C299.085 161.97 334.878 147.654 341.615 156.653C345.643 162.039 327.578 197.327 334.074 199.496C339.004 201.142 350.98 188.742 359.204 191.096C376.15 195.952 380.691 231.713 365.907 238.979C351.123 246.245 341.747 240.521 340.777 241.5C336.129 246.154 349.597 267.685 346.642 275.102C344.754 279.832 305.714 287.83 301.398 283.503C292.4 274.481 309.369 240.976 291.344 236.459C265.56 229.998 276.039 267.893 267.046 270.902C254.301 275.16 229.326 272.582 215.1 272.582" stroke="currentColor" stroke-opacity="0.9" stroke-width="16" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
    </div>

    <!-- Create Event Modal -->
    <div class="modal" id="createModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-user">
                    <img class="modal-user-avatar" id="modalUserAvatar" src="" alt="">
                    <div class="modal-user-name" id="modalUserName"></div>
                </div>
                <button class="modal-close" onclick="hideCreateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <form id="createEventForm">
                    <div class="form-group">
                        <label class="form-label">Title</label>
                        <input type="text" class="form-input" id="eventTitle" required placeholder="Event title" maxlength="64">
                        <div class="char-counter" id="titleCounter">0/64</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <textarea class="form-input" id="eventDescription" required placeholder="Describe your event..." maxlength="350" rows="4"></textarea>
                        <div class="char-counter" id="descCounter">0/350</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Location</label>
                        <input type="text" class="form-input" id="eventCity" placeholder="City">
                    </div>
                    
                    <div class="form-grid">
                        <div>
                            <label class="form-label">Category</label>
                            <select class="form-input" id="eventCategory">
                                <option value="">Select category</option>
                                <option value="meetup">Meetup</option>
                                <option value="party">Party</option>
                                <option value="sport">Sport</option>
                                <option value="culture">Culture</option>
                                <option value="business">Business</option>
                                <option value="education">Education</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label">Gender</label>
                            <select class="form-input" id="eventGender">
                                <option value="">Any gender</option>
                                <option value="male">Male</option>
                                <option value="female">Female</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label">Age group</label>
                            <select class="form-input" id="eventAge">
                                <option value="">Any age</option>
                                <option value="16-25">16-25</option>
                                <option value="25-45">25-45</option>
                                <option value="45+">45+</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-date-group">
                        <label>From:</label>
                        <input type="date" class="form-input" id="eventDateFrom">
                        <label>To:</label>
                        <input type="date" class="form-input" id="eventDateTo">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="submit" class="submit-btn" form="createEventForm">→</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            POSTS_API: 'https://sub-muey.onrender.com/api',
            ACCOUNTS_API: 'https://six-z05l.onrender.com/api',
            DB_NAME: 'EventsPlatform',
            DB_VERSION: 1
        }

        // Global state
        let app = {
            user: null,
            db: null,
            currentTab: 'feed',
            events: new Map(),
            userMeta: {
                likes: new Set(),
                favorites: new Set(),
                hidden: new Set()
            },
            lastSync: 0,
            isOnline: navigator.onLine,
            ws: null,
            openMenus: new Set()
        }

        // === TELEGRAM WEB APP INTEGRATION ===

        window.addEventListener('load', async () => {
            try {
                // Initialize Telegram Web App
                if (window.Telegram?.WebApp) {
                    const tg = window.Telegram.WebApp
                    tg.ready()
                    tg.expand()

                    // Set theme
                    document.documentElement.style.setProperty('--tg-theme-bg-color', tg.themeParams.bg_color || '#ffffff')
                    document.documentElement.style.setProperty('--tg-theme-text-color', tg.themeParams.text_color || '#000000')
                    document.documentElement.style.setProperty('--tg-theme-hint-color', tg.themeParams.hint_color || '#999999')
                    document.documentElement.style.setProperty('--tg-theme-button-color', tg.themeParams.button_color || '#0088cc')
                    document.documentElement.style.setProperty('--tg-theme-button-text-color', tg.themeParams.button_text_color || '#ffffff')
                    document.documentElement.style.setProperty('--tg-theme-secondary-bg-color', tg.themeParams.secondary_bg_color || '#f8f9fa')

                    // Get user data
                    if (tg.initDataUnsafe?.user) {
                        app.user = tg.initDataUnsafe.user
                    } else {
                        console.log('No Telegram user data, using demo user')
                        app.user = {
                            id: Date.now(),
                            first_name: 'Demo',
                            last_name: 'User',
                            username: 'demo_user'
                        }
                    }
                } else {
                    console.log('Not in Telegram, using demo user')
                    app.user = {
                        id: Date.now(),
                        first_name: 'Demo',
                        last_name: 'User',
                        username: 'demo_user'
                    }
                }

                await initializeApp()
            } catch (error) {
                console.error('App initialization error:', error)
            }
        })

        // === APP INITIALIZATION ===

        async function initializeApp() {
            try {
                // Initialize IndexedDB
                await initDB()

                // Authenticate user
                await authenticateUser()

                // Load data
                await loadData()

                // Setup event listeners
                setupEventListeners()

                // Start periodic sync
                startPeriodicSync()

                // Setup WebSocket for real-time updates
                setupWebSocket()

                // Setup user info in modal
                setupUserModal()

            } catch (error) {
                console.error('App initialization failed:', error)
            }
        }

        function setupUserModal() {
            const avatarUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(`${app.user.first_name} ${app.user.last_name || ''}`)}&size=40&background=random`
            document.getElementById('modalUserAvatar').src = avatarUrl
            document.getElementById('modalUserName').textContent = `${app.user.first_name} ${app.user.last_name || ''}`.trim()
        }

        // === CHARACTER COUNTERS ===

        function setupCharacterCounters() {
            const titleInput = document.getElementById('eventTitle')
            const descInput = document.getElementById('eventDescription')
            const titleCounter = document.getElementById('titleCounter')
            const descCounter = document.getElementById('descCounter')

            titleInput.addEventListener('input', () => {
                titleCounter.textContent = `${titleInput.value.length}/64`
            })

            descInput.addEventListener('input', () => {
                descCounter.textContent = `${descInput.value.length}/350`
            })
        }

        // === DATABASE ===

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(CONFIG.DB_NAME, CONFIG.DB_VERSION)

                request.onerror = () => reject(request.error)
                request.onsuccess = () => {
                    app.db = request.result
                    resolve()
                }

                request.onupgradeneeded = (event) => {
                    const db = event.target.result

                    // Events store
                    if (!db.objectStoreNames.contains('events')) {
                        const eventsStore = db.createObjectStore('events', { keyPath: 'id' })
                        eventsStore.createIndex('createdAt', 'createdAt')
                        eventsStore.createIndex('authorId', 'authorId')
                        eventsStore.createIndex('city', 'city')
                        eventsStore.createIndex('category', 'category')
                    }

                    // User meta store
                    if (!db.objectStoreNames.contains('userMeta')) {
                        db.createObjectStore('userMeta', { keyPath: 'type' })
                    }

                    // App state store
                    if (!db.objectStoreNames.contains('appState')) {
                        db.createObjectStore('appState', { keyPath: 'key' })
                    }
                }
            })
        }

        async function saveToIndexedDB(storeName, data) {
            const transaction = app.db.transaction([storeName], 'readwrite')
            const store = transaction.objectStore(storeName)

            if (Array.isArray(data)) {
                for (const item of data) {
                    await store.put(item)
                }
            } else {
                await store.put(data)
            }

            return transaction.complete
        }

        async function loadFromIndexedDB(storeName, query = null) {
            const transaction = app.db.transaction([storeName], 'readonly')
            const store = transaction.objectStore(storeName)

            if (query) {
                return store.get(query)
            } else {
                return store.getAll()
            }
        }

        // === WEBSOCKET REAL-TIME UPDATES ===

        function setupWebSocket() {
            if (!app.isOnline) return

            try {
                const wsUrl = CONFIG.POSTS_API.replace('https://', 'wss://').replace('http://', 'ws://').replace('/api', '')
                console.log('🔌 Connecting to WebSocket:', wsUrl)

                app.ws = new WebSocket(wsUrl)

                app.ws.onopen = () => {
                    console.log('✅ WebSocket connected')
                }

                app.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data)
                        handleWebSocketMessage(message)
                    } catch (error) {
                        console.error('WebSocket message parse error:', error)
                    }
                }

                app.ws.onclose = () => {
                    console.log('🔌 WebSocket disconnected')
                    app.ws = null

                    // Reconnect after 5 seconds if online
                    if (app.isOnline) {
                        setTimeout(setupWebSocket, 5000)
                    }
                }

                app.ws.onerror = (error) => {
                    console.error('WebSocket error:', error)
                }

            } catch (error) {
                console.error('WebSocket setup error:', error)
            }
        }

        function handleWebSocketMessage(message) {
            const { type, data } = message

            console.log('📡 WebSocket message:', type, data)

            switch (type) {
                case 'EVENT_CREATED':
                    if (data.authorId !== app.userId) {
                        app.events.set(data.id, data)
                        saveToIndexedDB('events', [data])

                        if (app.currentTab === 'feed') {
                            renderCurrentTab()
                        }
                    }
                    break

                case 'EVENT_UPDATED':
                    app.events.set(data.id, data)
                    saveToIndexedDB('events', [data])
                    renderCurrentTab()
                    break

                case 'EVENT_DELETED':
                    app.events.delete(data.id)
                    renderCurrentTab()
                    break

                case 'LIKE_UPDATED':
                    const likeEvent = app.events.get(data.eventId)
                    if (likeEvent) {
                        likeEvent.likes = data.likes
                        if (data.userId === app.userId) {
                            if (data.isLiked) {
                                app.userMeta.likes.add(data.eventId)
                            } else {
                                app.userMeta.likes.delete(data.eventId)
                            }
                        }
                        app.events.set(data.eventId, likeEvent)
                        renderCurrentTab()
                    }
                    break
            }
        }

        // === AUTHENTICATION ===

        async function authenticateUser() {
            try {
                const response = await fetch(`${CONFIG.ACCOUNTS_API}/users/auth`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ telegramUser: app.user })
                })

                if (!response.ok) {
                    throw new Error(`Auth failed: ${response.status}`)
                }

                const userData = await response.json()
                app.userId = userData.id

                console.log(`✅ Authenticated as ${userData.id}`)

            } catch (error) {
                console.error('Authentication error:', error)
                app.userId = `tg_${app.user.id}`
                console.log(`⚠️ Using fallback ID: ${app.userId}`)
            }
        }

        // === DATA LOADING ===

        async function loadData() {
            // Load from IndexedDB first
            await loadFromCache()

            // Then sync from servers
            await syncWithServers()

            // Render initial feed
            renderCurrentTab()
        }

        async function loadFromCache() {
            try {
                // Load events
                const events = await loadFromIndexedDB('events')
                events.forEach(event => app.events.set(event.id, event))

                // Load user meta
                const [likes, favorites, hidden] = await Promise.all([
                    loadFromIndexedDB('userMeta', 'likes'),
                    loadFromIndexedDB('userMeta', 'favorites'),
                    loadFromIndexedDB('userMeta', 'hidden')
                ])

                if (likes) app.userMeta.likes = new Set(likes.data || [])
                if (favorites) app.userMeta.favorites = new Set(favorites.data || [])
                if (hidden) app.userMeta.hidden = new Set(hidden.data || [])

                // Load app state
                const lastSyncState = await loadFromIndexedDB('appState', 'lastSync')
                if (lastSyncState) app.lastSync = lastSyncState.value || 0

                console.log(`📦 Loaded ${app.events.size} events from cache`)

            } catch (error) {
                console.error('Cache loading error:', error)
            }
        }

        async function syncWithServers() {
            if (!app.isOnline) {
                return
            }

            try {
                // Parallel requests
                const [eventsResponse, userMetaResponse] = await Promise.all([
                    fetch(`${CONFIG.POSTS_API}/feed?limit=100`).catch(() => null),
                    fetch(`${CONFIG.ACCOUNTS_API}/users/${app.userId}/meta?lastSync=${app.lastSync}`).catch(() => null)
                ])

                // Process events
                if (eventsResponse?.ok) {
                    const eventsData = await eventsResponse.json()
                    const events = eventsData.posts || []

                    for (const event of events) {
                        app.events.set(event.id, event)
                    }

                    await saveToIndexedDB('events', events)
                    console.log(`📥 Synced ${events.length} events`)
                }

                // Process user meta
                if (userMetaResponse?.ok) {
                    const userMeta = await userMetaResponse.json()

                    if (userMeta.isDelta) {
                        userMeta.likes?.forEach(id => app.userMeta.likes.add(id))
                        userMeta.favorites?.forEach(id => app.userMeta.favorites.add(id))
                        userMeta.hidden?.forEach(id => app.userMeta.hidden.add(id))
                    } else {
                        app.userMeta.likes = new Set(userMeta.likes || [])
                        app.userMeta.favorites = new Set(userMeta.favorites || [])
                        app.userMeta.hidden = new Set(userMeta.hidden || [])
                    }

                    await Promise.all([
                        saveToIndexedDB('userMeta', { type: 'likes', data: Array.from(app.userMeta.likes) }),
                        saveToIndexedDB('userMeta', { type: 'favorites', data: Array.from(app.userMeta.favorites) }),
                        saveToIndexedDB('userMeta', { type: 'hidden', data: Array.from(app.userMeta.hidden) })
                    ])

                    console.log(`👤 Synced user meta: ${app.userMeta.likes.size} likes, ${app.userMeta.favorites.size} favorites`)
                }

                app.lastSync = Date.now()
                await saveToIndexedDB('appState', { key: 'lastSync', value: app.lastSync })

            } catch (error) {
                console.error('Sync error:', error)
            }
        }

        // === EVENT LISTENERS ===

        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab))
            })

            // Filters
            document.getElementById('searchInput').addEventListener('input', debounce(renderCurrentTab, 300))
            document.getElementById('cityFilter').addEventListener('change', renderCurrentTab)
            document.getElementById('categoryFilter').addEventListener('change', renderCurrentTab)
            document.getElementById('genderFilter').addEventListener('change', renderCurrentTab)
            document.getElementById('ageFilter').addEventListener('change', renderCurrentTab)
            document.getElementById('dateFromFilter').addEventListener('change', renderCurrentTab)
            document.getElementById('dateToFilter').addEventListener('change', renderCurrentTab)

            // Create form
            document.getElementById('createEventForm').addEventListener('submit', handleCreateEvent)

            // Character counters
            setupCharacterCounters()

            // Modal close on outside click
            document.getElementById('createModal').addEventListener('click', (e) => {
                if (e.target === e.currentTarget) {
                    hideCreateModal()
                }
            })

            // Close menus on outside click
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.menu-container')) {
                    closeAllMenus()
                }
            })

            // Online/offline status
            window.addEventListener('online', () => {
                app.isOnline = true
                syncWithServers()
                setupWebSocket()
            })

            window.addEventListener('offline', () => {
                app.isOnline = false
                if (app.ws) {
                    app.ws.close()
                    app.ws = null
                }
            })
        }

        // === UI RENDERING ===

        function switchTab(tabName) {
            // Update active tab
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName)
            })

            // Hide all content
            document.querySelectorAll('[id$="Content"]').forEach(content => {
                content.classList.add('hidden')
            })

            // Show selected content
            document.getElementById(`${tabName}Content`).classList.remove('hidden')

            app.currentTab = tabName
            renderCurrentTab()
        }

        function renderCurrentTab() {
            console.log(`🎨 Rendering tab: ${app.currentTab}`)

            const events = getFilteredEvents()
            const container = document.getElementById(`${app.currentTab}Content`)

            if (events.length === 0) {
                container.innerHTML = `
                    <div class="empty">
                        <div style="font-size: 48px; margin-bottom: 16px;">📭</div>
                        <div>No events found</div>
                    </div>
                `
                return
            }

            container.innerHTML = events.map(event => renderEventCard(event)).join('')
            updateCityFilter(events)
        }

        function getFilteredEvents() {
            const search = document.getElementById('searchInput').value.toLowerCase()
            const city = document.getElementById('cityFilter').value
            const category = document.getElementById('categoryFilter').value
            const gender = document.getElementById('genderFilter').value
            const age = document.getElementById('ageFilter').value
            const dateFrom = document.getElementById('dateFromFilter').value
            const dateTo = document.getElementById('dateToFilter').value

            let events = Array.from(app.events.values())

            // Filter by tab
            if (app.currentTab === 'favorites') {
                events = events.filter(event => app.userMeta.favorites.has(event.id))
            } else if (app.currentTab === 'my-events') {
                events = events.filter(event => {
                    const matches = event.authorId === app.userId ||
                        event.authorId === app.user?.id?.toString() ||
                        event.authorId === `tg_${app.user?.id}`
                    return matches
                })
            } else if (app.currentTab === 'hidden') {
                events = events.filter(event => app.userMeta.hidden.has(event.id))
            }

            // Filter by search
            if (search) {
                events = events.filter(event =>
                    event.title.toLowerCase().includes(search) ||
                    event.description.toLowerCase().includes(search)
                )
            }

            // Filter by other criteria
            if (city) events = events.filter(event => event.city === city)
            if (category) events = events.filter(event => event.category === category)
            if (gender) events = events.filter(event => event.gender === gender)
            if (age) events = events.filter(event => event.ageGroup === age)
            
            // Date filters
            if (dateFrom) {
                events = events.filter(event => {
                    const eventDate = event.dateFrom || event.createdAt
                    return new Date(eventDate) >= new Date(dateFrom)
                })
            }
            if (dateTo) {
                events = events.filter(event => {
                    const eventDate = event.dateTo || event.createdAt
                    return new Date(eventDate) <= new Date(dateTo)
                })
            }

            // Hide hidden events (except in my-events and hidden tab)
            if (app.currentTab !== 'my-events' && app.currentTab !== 'hidden') {
                events = events.filter(event => !app.userMeta.hidden.has(event.id))
            }

            // Sort by creation date (newest first)
            events.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))

            return events.slice(0, 50)
        }

        function renderEventCard(event) {
            const isLiked = app.userMeta.likes.has(event.id)
            const isOwn = event.authorId === app.userId

            const author = event.author?.fullName || event.author || 'Anonymous'
            const avatarUrl = getUserAvatar(event.authorId, author)

            return `
                <div class="event-card">
                    <div class="event-content">
                        <div class="event-title">${escapeHtml(event.title)}</div>
                        <div class="event-description">${escapeHtml(event.description)}</div>
                    </div>
                    <div class="event-footer">
                        <div class="event-author" onclick="openUserProfile('${event.authorId}', '${event.author?.username || ''}')">
                            <img src="${avatarUrl}" alt="${author}" class="author-avatar">
                            <div class="author-name">${escapeHtml(author)}</div>
                        </div>
                        <div class="event-actions">
                            <button class="like-btn ${isLiked ? 'liked' : ''}" onclick="toggleLike('${event.id}')">
                                ${isLiked ? '❤️' : '🤍'} ${event.likes || 0}
                            </button>
                            <div class="menu-container">
                                <button class="menu-btn" onclick="toggleMenu('${event.id}', ${isOwn})">
                                    ⋯
                                </button>
                                <div class="dropdown-menu" id="menu-${event.id}">
                                    ${isOwn ? `
                                        <button class="dropdown-item" onclick="editEvent('${event.id}')">Edit</button>
                                        <button class="dropdown-item danger" onclick="deleteEvent('${event.id}')">Delete</button>
                                    ` : `
                                        <button class="dropdown-item" onclick="toggleFavorite('${event.id}')">${app.userMeta.favorites.has(event.id) ? 'Remove from favorites' : 'Add to favorites'}</button>
                                        <button class="dropdown-item" onclick="toggleHidden('${event.id}')">${app.userMeta.hidden.has(event.id) ? 'Show' : 'Hide'}</button>
                                        <button class="dropdown-item danger" onclick="reportEvent('${event.id}')">Report</button>
                                    `}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `
        }

        function getUserAvatar(authorId, authorName) {
            return `https://ui-avatars.com/api/?name=${encodeURIComponent(authorName)}&size=32&background=random`
        }

        function updateCityFilter(events) {
            const citySelect = document.getElementById('cityFilter')
            const currentValue = citySelect.value

            const cities = [...new Set(events.map(e => e.city).filter(Boolean))].sort()

            citySelect.innerHTML = '<option value="">All cities</option>' +
                cities.map(city => `<option value="${city}">${city}</option>`).join('')

            citySelect.value = currentValue
        }

        // === MENU FUNCTIONS ===

        function toggleMenu(eventId, isOwn) {
            const menu = document.getElementById(`menu-${eventId}`)
            const isOpen = menu.classList.contains('show')
            
            // Close all menus first
            closeAllMenus()
            
            if (!isOpen) {
                menu.classList.add('show')
                app.openMenus.add(eventId)
            }
        }

        function closeAllMenus() {
            document.querySelectorAll('.dropdown-menu').forEach(menu => {
                menu.classList.remove('show')
            })
            app.openMenus.clear()
        }

        // === EVENT ACTIONS ===

        async function toggleLike(eventId) {
            const event = app.events.get(eventId)
            if (!event) return

            const isLiked = app.userMeta.likes.has(eventId)
            const newLikedState = !isLiked

            try {
                // Optimistic UI update
                if (newLikedState) {
                    app.userMeta.likes.add(eventId)
                    event.likes = (event.likes || 0) + 1
                } else {
                    app.userMeta.likes.delete(eventId)
                    event.likes = Math.max(0, (event.likes || 0) - 1)
                }

                renderCurrentTab()

                if (app.ws && app.ws.readyState === WebSocket.OPEN) {
                    app.ws.send(JSON.stringify({
                        type: 'LIKE_UPDATED',
                        data: { eventId, likes: event.likes, userId: app.userId, isLiked: newLikedState }
                    }))
                }

                // Save to IndexedDB
                await saveToIndexedDB('userMeta', { type: 'likes', data: Array.from(app.userMeta.likes) })
                await saveToIndexedDB('events', [event])

                // Sync with servers (if online)
                if (app.isOnline) {
                    const [postsResponse, accountsResponse] = await Promise.all([
                        fetch(`${CONFIG.POSTS_API}/events/${eventId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ likes: event.likes })
                        }).catch(() => null),

                        newLikedState ?
                            fetch(`${CONFIG.ACCOUNTS_API}/users/${app.userId}/likes/${eventId}`, { method: 'POST' }).catch(() => null) :
                            fetch(`${CONFIG.ACCOUNTS_API}/users/${app.userId}/likes/${eventId}`, { method: 'DELETE' }).catch(() => null)
                    ])
                }

            } catch (error) {
                console.error('Like toggle error:', error)
                // Revert optimistic update
                if (isLiked) {
                    app.userMeta.likes.add(eventId)
                    event.likes = (event.likes || 0) + 1
                } else {
                    app.userMeta.likes.delete(eventId)
                    event.likes = Math.max(0, (event.likes || 0) - 1)
                }
                renderCurrentTab()
            }
        }

        async function toggleFavorite(eventId) {
            const isFavorited = app.userMeta.favorites.has(eventId)
            const newState = !isFavorited

            try {
                // Optimistic UI update
                if (newState) {
                    app.userMeta.favorites.add(eventId)
                } else {
                    app.userMeta.favorites.delete(eventId)
                }

                closeAllMenus()
                renderCurrentTab()

                // Save to IndexedDB
                await saveToIndexedDB('userMeta', { type: 'favorites', data: Array.from(app.userMeta.favorites) })

                // Sync with server (if online)
                if (app.isOnline) {
                    await (newState ?
                        fetch(`${CONFIG.ACCOUNTS_API}/users/${app.userId}/favorites/${eventId}`, { method: 'POST' }) :
                        fetch(`${CONFIG.ACCOUNTS_API}/users/${app.userId}/favorites/${eventId}`, { method: 'DELETE' })
                    ).catch(() => null)
                }

            } catch (error) {
                console.error('Favorite toggle error:', error)
                // Revert
                if (isFavorited) {
                    app.userMeta.favorites.add(eventId)
                } else {
                    app.userMeta.favorites.delete(eventId)
                }
                renderCurrentTab()
            }
        }

        async function toggleHidden(eventId) {
            const isHidden = app.userMeta.hidden.has(eventId)
            const newState = !isHidden

            try {
                if (newState) {
                    app.userMeta.hidden.add(eventId)
                } else {
                    app.userMeta.hidden.delete(eventId)
                }

                closeAllMenus()
                renderCurrentTab()

                await saveToIndexedDB('userMeta', { type: 'hidden', data: Array.from(app.userMeta.hidden) })

                if (app.isOnline) {
                    await (newState ?
                        fetch(`${CONFIG.ACCOUNTS_API}/users/${app.userId}/hidden/${eventId}`, { method: 'POST' }) :
                        fetch(`${CONFIG.ACCOUNTS_API}/users/${app.userId}/hidden/${eventId}`, { method: 'DELETE' })
                    ).catch(() => null)
                }

            } catch (error) {
                console.error('Hidden toggle error:', error)
                if (isHidden) {
                    app.userMeta.hidden.add(eventId)
                } else {
                    app.userMeta.hidden.delete(eventId)
                }
                renderCurrentTab()
            }
        }

        function editEvent(eventId) {
            // TODO: Implement edit functionality
            closeAllMenus()
            console.log('Edit event:', eventId)
        }

        async function deleteEvent(eventId) {
            if (!confirm('Are you sure you want to delete this event?')) {
                return
            }

            try {
                closeAllMenus()
                
                // Remove from local storage
                app.events.delete(eventId)
                renderCurrentTab()

                // Sync with server
                if (app.isOnline) {
                    await fetch(`${CONFIG.POSTS_API}/events/${eventId}`, {
                        method: 'DELETE'
                    }).catch(() => null)
                }

            } catch (error) {
                console.error('Delete event error:', error)
            }
        }

        function reportEvent(eventId) {
            closeAllMenus()
            alert('Event reported. Thank you for helping keep our community safe.')
            console.log('Report event:', eventId)
        }

        function openUserProfile(authorId, username) {
            try {
                console.log('📞 Opening user profile:', { authorId, username })

                if (window.Telegram?.WebApp) {
                    // Try username first
                    if (username && username !== 'undefined') {
                        const chatUrl = `https://t.me/${username}`
                        console.log('📞 Opening chat via username:', chatUrl)

                        if (window.Telegram.WebApp.openTelegramLink) {
                            window.Telegram.WebApp.openTelegramLink(chatUrl)
                        } else {
                            window.open(chatUrl, '_blank')
                        }
                        return
                    }

                    // Try Telegram ID
                    let telegramId = null
                    if (authorId.startsWith('tg_')) {
                        telegramId = authorId.replace('tg_', '')
                    }

                    if (telegramId && telegramId !== 'undefined') {
                        const chatUrl = `https://t.me/user?id=${telegramId}`
                        console.log('📞 Opening chat via ID:', chatUrl)

                        if (window.Telegram.WebApp.openTelegramLink) {
                            window.Telegram.WebApp.openTelegramLink(chatUrl)
                        } else {
                            window.open(chatUrl, '_blank')
                        }
                    } else {
                        alert('Cannot contact this user')
                    }
                } else {
                    alert('Contact feature available only in Telegram')
                }
            } catch (error) {
                console.error('Error opening user profile:', error)
                alert('Could not open user profile. Please try again.')
            }
        }

        // === CREATE EVENT ===

        function showCreateModal() {
            document.getElementById('createModal').classList.add('show')
        }

        function hideCreateModal() {
            document.getElementById('createModal').classList.remove('show')
            document.getElementById('createEventForm').reset()
            document.getElementById('titleCounter').textContent = '0/64'
            document.getElementById('descCounter').textContent = '0/350'
        }

        async function handleCreateEvent(e) {
            e.preventDefault()

            const title = document.getElementById('eventTitle').value.trim()
            const description = document.getElementById('eventDescription').value.trim()
            const city = document.getElementById('eventCity').value.trim()
            const category = document.getElementById('eventCategory').value
            const gender = document.getElementById('eventGender').value
            const ageGroup = document.getElementById('eventAge').value
            const dateFrom = document.getElementById('eventDateFrom').value
            const dateTo = document.getElementById('eventDateTo').value

            if (!title || !description) {
                alert('Please fill in title and description')
                return
            }

            try {
                const eventData = {
                    title,
                    description,
                    city,
                    category,
                    gender,
                    ageGroup,
                    dateFrom,
                    dateTo,
                    authorId: app.userId,
                    author: {
                        fullName: `${app.user.first_name} ${app.user.last_name || ''}`.trim(),
                        username: app.user.username,
                        telegramId: app.user.id
                    }
                }

                console.log(`📝 Creating event with authorId: ${app.userId}`)

                // Create locally first
                const localEvent = {
                    id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    ...eventData,
                    likes: 0,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    status: 'active'
                }

                app.events.set(localEvent.id, localEvent)

                if (app.ws && app.ws.readyState === WebSocket.OPEN) {
                    app.ws.send(JSON.stringify({
                        type: 'EVENT_CREATED',
                        data: localEvent
                    }))
                }
                await saveToIndexedDB('events', [localEvent])

                hideCreateModal()
                renderCurrentTab()

                // Sync with server (if online)
                if (app.isOnline) {
                    try {
                        const response = await fetch(`${CONFIG.POSTS_API}/events`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(eventData)
                        })

                        if (response.ok) {
                            const serverEvent = await response.json()
                            // Replace local event with server event
                            app.events.delete(localEvent.id)
                            app.events.set(serverEvent.id, serverEvent)
                            await saveToIndexedDB('events', [serverEvent])
                            renderCurrentTab()
                            console.log('✅ Event synced with server')
                        }
                    } catch (error) {
                        console.error('Server sync failed:', error)
                    }
                }

            } catch (error) {
                console.error('Create event error:', error)
            }
        }

        // === UTILITIES ===

        function clearFilters() {
            document.getElementById('searchInput').value = ''
            document.getElementById('cityFilter').value = ''
            document.getElementById('categoryFilter').value = ''
            document.getElementById('genderFilter').value = ''
            document.getElementById('ageFilter').value = ''
            document.getElementById('dateFromFilter').value = ''
            document.getElementById('dateToFilter').value = ''
            renderCurrentTab()
        }

        function escapeHtml(text) {
            const div = document.createElement('div')
            div.textContent = text
            return div.innerHTML
        }

        function debounce(func, wait) {
            let timeout
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout)
                    func(...args)
                }
                clearTimeout(timeout)
                timeout = setTimeout(later, wait)
            }
        }

        function startPeriodicSync() {
            // Sync every 30 seconds when online
            setInterval(() => {
                if (app.isOnline) {
                    syncWithServers()

                    // Check WebSocket connection
                    if (!app.ws || app.ws.readyState !== WebSocket.OPEN) {
                        console.log('🔌 WebSocket reconnecting...')
                        setupWebSocket()
                    }
                }
            }, 30000)
        }
    </script>
</body>

</html>
